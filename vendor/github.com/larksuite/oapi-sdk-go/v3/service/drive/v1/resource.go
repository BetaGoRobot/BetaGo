// Code generated by Lark OpenAPI.

package larkdrive

import (
	"bytes"
	"context"
	"github.com/larksuite/oapi-sdk-go/v3/core"
	"net/http"
)

type V1 struct {
	ExportTask               *exportTask               // 导出
	File                     *file                     // 文件
	FileComment              *fileComment              // 评论
	FileCommentReply         *fileCommentReply         // 评论
	FileStatistics           *fileStatistics           // file.statistics
	FileSubscription         *fileSubscription         // 订阅
	FileVersion              *fileVersion              // 文档版本
	FileViewRecord           *fileViewRecord           // file.view_record
	ImportTask               *importTask               // 导入
	Media                    *media                    // 素材
	Meta                     *meta                     // meta
	PermissionMember         *permissionMember         // 成员
	PermissionPublic         *permissionPublic         // 设置
	PermissionPublicPassword *permissionPublicPassword // permission.public.password
}

func New(config *larkcore.Config) *V1 {
	return &V1{
		ExportTask:               &exportTask{config: config},
		File:                     &file{config: config},
		FileComment:              &fileComment{config: config},
		FileCommentReply:         &fileCommentReply{config: config},
		FileStatistics:           &fileStatistics{config: config},
		FileSubscription:         &fileSubscription{config: config},
		FileVersion:              &fileVersion{config: config},
		FileViewRecord:           &fileViewRecord{config: config},
		ImportTask:               &importTask{config: config},
		Media:                    &media{config: config},
		Meta:                     &meta{config: config},
		PermissionMember:         &permissionMember{config: config},
		PermissionPublic:         &permissionPublic{config: config},
		PermissionPublicPassword: &permissionPublicPassword{config: config},
	}
}

type exportTask struct {
	config *larkcore.Config
}
type file struct {
	config *larkcore.Config
}
type fileComment struct {
	config *larkcore.Config
}
type fileCommentReply struct {
	config *larkcore.Config
}
type fileStatistics struct {
	config *larkcore.Config
}
type fileSubscription struct {
	config *larkcore.Config
}
type fileVersion struct {
	config *larkcore.Config
}
type fileViewRecord struct {
	config *larkcore.Config
}
type importTask struct {
	config *larkcore.Config
}
type media struct {
	config *larkcore.Config
}
type meta struct {
	config *larkcore.Config
}
type permissionMember struct {
	config *larkcore.Config
}
type permissionPublic struct {
	config *larkcore.Config
}
type permissionPublicPassword struct {
	config *larkcore.Config
}

// Create 创建导出任务
//
// - 创建导出任务，将云文件导出为指定格式的本地文件。该接口为异步接口，需要通过轮询 [查询导出任务结果](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/export_task/get) 接口获取任务结果。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/export_task/create
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/create_exportTask.go
func (e *exportTask) Create(ctx context.Context, req *CreateExportTaskReq, options ...larkcore.RequestOptionFunc) (*CreateExportTaskResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/export_tasks"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, e.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &CreateExportTaskResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, e.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Download 下载导出文件
//
// - 根据任务导出结果的token，下载导出文件
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/export_task/download
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/download_exportTask.go
func (e *exportTask) Download(ctx context.Context, req *DownloadExportTaskReq, options ...larkcore.RequestOptionFunc) (*DownloadExportTaskResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/export_tasks/file/:file_token/download"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, e.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &DownloadExportTaskResp{ApiResp: apiResp}
	// 如果是下载，则设置响应结果
	if apiResp.StatusCode == http.StatusOK {
		resp.File = bytes.NewBuffer(apiResp.RawBody)
		resp.FileName = larkcore.FileNameByHeader(apiResp.Header)
		return resp, err
	}
	err = apiResp.JSONUnmarshalBody(resp, e.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Get 查询导出任务结果
//
// - 根据[创建导出任务](/ssl::ttdoc//uAjLw4CM/ukTMukTMukTM/reference/drive-v1/export_task/create)的ticket查询导出任务的结果，前提条件需要先调用创建导出任务接口。;;通过该接口获取到下载文件的 token 后调用[下载导出文件接口](/ssl::ttdoc//uAjLw4CM/ukTMukTMukTM/reference/drive-v1/export_task/download)将文件进行下载
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/export_task/get
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/get_exportTask.go
func (e *exportTask) Get(ctx context.Context, req *GetExportTaskReq, options ...larkcore.RequestOptionFunc) (*GetExportTaskResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/export_tasks/:ticket"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, e.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &GetExportTaskResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, e.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Copy 复制文件
//
// - 将文件复制到用户云空间的其他文件夹中。不支持复制文件夹。;;如果目标文件夹是我的空间，则复制的文件会在「**我的空间**」的「**归我所有**」列表里。
//
// - 该接口不支持并发拷贝多个文件，且调用频率上限为 5QPS 且 10000次/天
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file/copy
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/copy_file.go
func (f *file) Copy(ctx context.Context, req *CopyFileReq, options ...larkcore.RequestOptionFunc) (*CopyFileResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/copy"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &CopyFileResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// CreateFolder 新建文件夹
//
// - 在用户云空间的指定文件夹中创建一个新的空文件夹。
//
// - 该接口不支持并发创建，且调用频率上限为 5QPS 以及 10000次/天
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file/create_folder
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/createFolder_file.go
func (f *file) CreateFolder(ctx context.Context, req *CreateFolderFileReq, options ...larkcore.RequestOptionFunc) (*CreateFolderFileResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/create_folder"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &CreateFolderFileResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// CreateShortcut
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=create_shortcut&project=drive&resource=file&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/createShortcut_file.go
func (f *file) CreateShortcut(ctx context.Context, req *CreateShortcutFileReq, options ...larkcore.RequestOptionFunc) (*CreateShortcutFileResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/create_shortcut"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &CreateShortcutFileResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Delete 删除文件
//
// - 删除用户在云空间内的文件或者文件夹。文件或者文件夹被删除后，会进入用户回收站里。
//
// - 要删除文件需要确保应用具有下述两种权限之一：;1. 该应用是文件所有者并且具有该文件所在父文件夹的编辑权限。;2. 该应用并非文件所有者，但是是该文件所在父文件夹的所有者或者拥有该父文件夹的所有权限（full access）。
//
// - 该接口不支持并发调用，且调用频率上限为5QPS。删除文件夹会异步执行并返回一个task_id，可以使用[task_check](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file/task_check)接口查询任务执行状态。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file/delete
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/delete_file.go
func (f *file) Delete(ctx context.Context, req *DeleteFileReq, options ...larkcore.RequestOptionFunc) (*DeleteFileResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token"
	apiReq.HttpMethod = http.MethodDelete
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &DeleteFileResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// DeleteSubscribe 取消云文档事件订阅情况
//
// - 该接口**仅支持文档拥有者**取消订阅自己文档的通知事件，可订阅的文档类型为**旧版文档**、**新版文档**、**电子表格**和**多维表格**。在调用该接口之前请确保正确[配置事件回调网址和订阅事件类型](https://open.feishu.cn/document/ukTMukTMukTM/uUTNz4SN1MjL1UzM#2eb3504a)，事件类型参考[事件列表](https://open.feishu.cn/document/ukTMukTMukTM/uYDNxYjL2QTM24iN0EjN/event-list)。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file/delete_subscribe
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/deleteSubscribe_file.go
func (f *file) DeleteSubscribe(ctx context.Context, req *DeleteSubscribeFileReq, options ...larkcore.RequestOptionFunc) (*DeleteSubscribeFileResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/delete_subscribe"
	apiReq.HttpMethod = http.MethodDelete
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &DeleteSubscribeFileResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Download 下载文件
//
// - 使用该接口可以下载在云空间目录下的文件（不含飞书文档/表格/思维导图等在线文档）。支持range下载。
//
// - 该接口支持调用频率上限为5QPS
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file/download
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/download_file.go
func (f *file) Download(ctx context.Context, req *DownloadFileReq, options ...larkcore.RequestOptionFunc) (*DownloadFileResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/download"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &DownloadFileResp{ApiResp: apiResp}
	// 如果是下载，则设置响应结果
	if apiResp.StatusCode == http.StatusOK {
		resp.File = bytes.NewBuffer(apiResp.RawBody)
		resp.FileName = larkcore.FileNameByHeader(apiResp.Header)
		return resp, err
	}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// GetSubscribe 查询云文档事件订阅状态
//
// - 该接口**仅支持文档拥有者**查询自己文档的订阅状态，可订阅的文档类型为**旧版文档**、**新版文档**、**电子表格**和**多维表格**。在调用该接口之前请确保正确[配置事件回调网址和订阅事件类型](https://open.feishu.cn/document/ukTMukTMukTM/uUTNz4SN1MjL1UzM#2eb3504a)，事件类型参考[事件列表](https://open.feishu.cn/document/ukTMukTMukTM/uYDNxYjL2QTM24iN0EjN/event-list)。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file/get_subscribe
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/getSubscribe_file.go
func (f *file) GetSubscribe(ctx context.Context, req *GetSubscribeFileReq, options ...larkcore.RequestOptionFunc) (*GetSubscribeFileResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/get_subscribe"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &GetSubscribeFileResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// List 获取文件夹下的清单
//
// - 获取用户云空间中指定文件夹下的文件清单。清单类型包括文件、各种在线文档（文档、电子表格、多维表格、思维笔记）、文件夹和快捷方式。该接口支持分页，但是不会递归的获取子文件夹的清单。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file/list
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/list_file.go
func (f *file) List(ctx context.Context, req *ListFileReq, options ...larkcore.RequestOptionFunc) (*ListFileResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &ListFileResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Move 移动文件
//
// - 将文件或者文件夹移动到用户云空间的其他位置。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file/move
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/move_file.go
func (f *file) Move(ctx context.Context, req *MoveFileReq, options ...larkcore.RequestOptionFunc) (*MoveFileResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/move"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &MoveFileResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Subscribe 订阅云文档事件
//
// - 该接口仅支持**文档拥有者**订阅自己文档的通知事件，可订阅的文档类型为**旧版文档**、**新版文档**、**电子表格**和**多维表格**。在调用该接口之前请确保正确[配置事件回调网址和订阅事件类型](https://open.feishu.cn/document/ukTMukTMukTM/uUTNz4SN1MjL1UzM#2eb3504a)(暂不支持单独订阅文档维度的某类事件)，事件类型参考[事件列表](https://open.feishu.cn/document/ukTMukTMukTM/uYDNxYjL2QTM24iN0EjN/event-list)。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file/subscribe
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/subscribe_file.go
func (f *file) Subscribe(ctx context.Context, req *SubscribeFileReq, options ...larkcore.RequestOptionFunc) (*SubscribeFileResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/subscribe"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &SubscribeFileResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// TaskCheck 查询异步任务状态
//
// - 查询删除文件夹等异步任务的状态信息。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file/task_check
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/taskCheck_file.go
func (f *file) TaskCheck(ctx context.Context, req *TaskCheckFileReq, options ...larkcore.RequestOptionFunc) (*TaskCheckFileResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/task_check"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &TaskCheckFileResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// UploadAll 上传文件
//
// - 向云空间指定目录下上传一个小文件。
//
// - 请不要使用这个接口上传大于20MB的文件，如果有这个需求可以尝试使用[分片上传接口](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file/multipart-upload-file-/introduction)。
//
// - 该接口支持调用频率上限为5QPS
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file/upload_all
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/uploadAll_file.go
func (f *file) UploadAll(ctx context.Context, req *UploadAllFileReq, options ...larkcore.RequestOptionFunc) (*UploadAllFileResp, error) {
	options = append(options, larkcore.WithFileUpload())
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/upload_all"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &UploadAllFileResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// UploadFinish 分片上传文件（完成上传）
//
// - 触发完成上传。
//
// - 该接口不支持太高的并发，且调用频率上限为5QPS
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file/upload_finish
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/uploadFinish_file.go
func (f *file) UploadFinish(ctx context.Context, req *UploadFinishFileReq, options ...larkcore.RequestOptionFunc) (*UploadFinishFileResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/upload_finish"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &UploadFinishFileResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// UploadPart 分片上传文件（上传分片）
//
// - 上传对应的文件块。
//
// - 该接口不支持太高的并发，且调用频率上限为5QPS
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file/upload_part
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/uploadPart_file.go
func (f *file) UploadPart(ctx context.Context, req *UploadPartFileReq, options ...larkcore.RequestOptionFunc) (*UploadPartFileResp, error) {
	options = append(options, larkcore.WithFileUpload())
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/upload_part"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &UploadPartFileResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// UploadPrepare 分片上传文件（预上传）
//
// - 发送初始化请求获取上传事务ID和分块策略，目前是以4MB大小进行定长分片。
//
// - 你在24小时内可保存上传事务ID和上传进度，以便可以恢复上传
//
// - 该接口不支持太高的并发，且调用频率上限为5QPS
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file/upload_prepare
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/uploadPrepare_file.go
func (f *file) UploadPrepare(ctx context.Context, req *UploadPrepareFileReq, options ...larkcore.RequestOptionFunc) (*UploadPrepareFileResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/upload_prepare"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &UploadPrepareFileResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// BatchQuery 批量获取评论
//
// - 该接口用于根据评论 ID 列表批量获取评论。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file-comment/batch_query
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/batchQuery_fileComment.go
func (f *fileComment) BatchQuery(ctx context.Context, req *BatchQueryFileCommentReq, options ...larkcore.RequestOptionFunc) (*BatchQueryFileCommentResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/comments/batch_query"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &BatchQueryFileCommentResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Create 添加评论
//
// - 往云文档添加一条全局评论。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file-comment/create
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/create_fileComment.go
func (f *fileComment) Create(ctx context.Context, req *CreateFileCommentReq, options ...larkcore.RequestOptionFunc) (*CreateFileCommentResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/comments"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &CreateFileCommentResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Get 获取评论
//
// - 获取云文档中的某条评论。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file-comment/get
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/get_fileComment.go
func (f *fileComment) Get(ctx context.Context, req *GetFileCommentReq, options ...larkcore.RequestOptionFunc) (*GetFileCommentResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/comments/:comment_id"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &GetFileCommentResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// List 分页获取文档评论
//
// - 该接口用于根据文档 token 分页获取文档评论。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file-comment/list
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/list_fileComment.go
func (f *fileComment) List(ctx context.Context, req *ListFileCommentReq, options ...larkcore.RequestOptionFunc) (*ListFileCommentResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/comments"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &ListFileCommentResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (f *fileComment) ListByIterator(ctx context.Context, req *ListFileCommentReq, options ...larkcore.RequestOptionFunc) (*ListFileCommentIterator, error) {
	return &ListFileCommentIterator{
		ctx:      ctx,
		req:      req,
		listFunc: f.List,
		options:  options,
		limit:    req.Limit}, nil
}

// Patch 解决/恢复 评论
//
// - 解决或恢复云文档中的评论。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file-comment/patch
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/patch_fileComment.go
func (f *fileComment) Patch(ctx context.Context, req *PatchFileCommentReq, options ...larkcore.RequestOptionFunc) (*PatchFileCommentResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/comments/:comment_id"
	apiReq.HttpMethod = http.MethodPatch
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &PatchFileCommentResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Delete 删除回复
//
// - 删除云文档中的某条回复。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file-comment-reply/delete
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/delete_fileCommentReply.go
func (f *fileCommentReply) Delete(ctx context.Context, req *DeleteFileCommentReplyReq, options ...larkcore.RequestOptionFunc) (*DeleteFileCommentReplyResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/comments/:comment_id/replies/:reply_id"
	apiReq.HttpMethod = http.MethodDelete
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &DeleteFileCommentReplyResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// List 获取回复
//
// - 该接口用于根据评论 ID 以及分页参数，获取回复。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file-comment-reply/list
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/list_fileCommentReply.go
func (f *fileCommentReply) List(ctx context.Context, req *ListFileCommentReplyReq, options ...larkcore.RequestOptionFunc) (*ListFileCommentReplyResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/comments/:comment_id/replies"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &ListFileCommentReplyResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (f *fileCommentReply) ListByIterator(ctx context.Context, req *ListFileCommentReplyReq, options ...larkcore.RequestOptionFunc) (*ListFileCommentReplyIterator, error) {
	return &ListFileCommentReplyIterator{
		ctx:      ctx,
		req:      req,
		listFunc: f.List,
		options:  options,
		limit:    req.Limit}, nil
}

// Update 更新回复
//
// - 更新云文档中的某条回复。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file-comment-reply/update
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/update_fileCommentReply.go
func (f *fileCommentReply) Update(ctx context.Context, req *UpdateFileCommentReplyReq, options ...larkcore.RequestOptionFunc) (*UpdateFileCommentReplyResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/comments/:comment_id/replies/:reply_id"
	apiReq.HttpMethod = http.MethodPut
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &UpdateFileCommentReplyResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Get 获取文件统计信息
//
// - 此接口用于获取文件统计信息，包括文档阅读人数、次数和点赞数。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file-statistics/get
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/get_fileStatistics.go
func (f *fileStatistics) Get(ctx context.Context, req *GetFileStatisticsReq, options ...larkcore.RequestOptionFunc) (*GetFileStatisticsResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/statistics"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &GetFileStatisticsResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Create 创建订阅
//
// - 订阅文档中的变更事件，当前支持文档评论订阅，订阅后文档评论更新会有“云文档助手”推送给订阅的用户
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file-subscription/create
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/create_fileSubscription.go
func (f *fileSubscription) Create(ctx context.Context, req *CreateFileSubscriptionReq, options ...larkcore.RequestOptionFunc) (*CreateFileSubscriptionResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/subscriptions"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &CreateFileSubscriptionResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Get 获取订阅状态
//
// - 根据订阅ID获取该订阅的状态
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file-subscription/get
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/get_fileSubscription.go
func (f *fileSubscription) Get(ctx context.Context, req *GetFileSubscriptionReq, options ...larkcore.RequestOptionFunc) (*GetFileSubscriptionResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/subscriptions/:subscription_id"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &GetFileSubscriptionResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Patch 更新订阅状态
//
// - 根据订阅ID更新订阅状态
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file-subscription/patch
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/patch_fileSubscription.go
func (f *fileSubscription) Patch(ctx context.Context, req *PatchFileSubscriptionReq, options ...larkcore.RequestOptionFunc) (*PatchFileSubscriptionResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/subscriptions/:subscription_id"
	apiReq.HttpMethod = http.MethodPatch
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &PatchFileSubscriptionResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Create 创建文档版本
//
// - 创建文档版本。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file-version/create
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/create_fileVersion.go
func (f *fileVersion) Create(ctx context.Context, req *CreateFileVersionReq, options ...larkcore.RequestOptionFunc) (*CreateFileVersionResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/versions"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &CreateFileVersionResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Delete 删除文档版本
//
// - 删除文档版本。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file-version/delete
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/delete_fileVersion.go
func (f *fileVersion) Delete(ctx context.Context, req *DeleteFileVersionReq, options ...larkcore.RequestOptionFunc) (*DeleteFileVersionResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/versions/:version_id"
	apiReq.HttpMethod = http.MethodDelete
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &DeleteFileVersionResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Get 获取文档版本
//
// - 获取文档版本。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file-version/get
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/get_fileVersion.go
func (f *fileVersion) Get(ctx context.Context, req *GetFileVersionReq, options ...larkcore.RequestOptionFunc) (*GetFileVersionResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/versions/:version_id"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &GetFileVersionResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// List 获取文档版本列表
//
// - 获取文档所有版本。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/file-version/list
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/list_fileVersion.go
func (f *fileVersion) List(ctx context.Context, req *ListFileVersionReq, options ...larkcore.RequestOptionFunc) (*ListFileVersionResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/versions"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &ListFileVersionResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (f *fileVersion) ListByIterator(ctx context.Context, req *ListFileVersionReq, options ...larkcore.RequestOptionFunc) (*ListFileVersionIterator, error) {
	return &ListFileVersionIterator{
		ctx:      ctx,
		req:      req,
		listFunc: f.List,
		options:  options,
		limit:    req.Limit}, nil
}

// List
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=list&project=drive&resource=file.view_record&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/list_fileViewRecord.go
func (f *fileViewRecord) List(ctx context.Context, req *ListFileViewRecordReq, options ...larkcore.RequestOptionFunc) (*ListFileViewRecordResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/files/:file_token/view_records"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &ListFileViewRecordResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (f *fileViewRecord) ListByIterator(ctx context.Context, req *ListFileViewRecordReq, options ...larkcore.RequestOptionFunc) (*ListFileViewRecordIterator, error) {
	return &ListFileViewRecordIterator{
		ctx:      ctx,
		req:      req,
		listFunc: f.List,
		options:  options,
		limit:    req.Limit}, nil
}

// Create 创建导入任务
//
// - 创建导入任务。支持导入为 doc、docx、sheet、bitable，参考[导入用户指南](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/import_task/import-user-guide)
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/import_task/create
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/create_importTask.go
func (i *importTask) Create(ctx context.Context, req *CreateImportTaskReq, options ...larkcore.RequestOptionFunc) (*CreateImportTaskResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/import_tasks"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, i.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &CreateImportTaskResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, i.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Get 查询导入结果
//
// - 根据创建导入任务返回的 ticket 查询导入结果。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/import_task/get
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/get_importTask.go
func (i *importTask) Get(ctx context.Context, req *GetImportTaskReq, options ...larkcore.RequestOptionFunc) (*GetImportTaskResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/import_tasks/:ticket"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, i.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &GetImportTaskResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, i.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// BatchGetTmpDownloadUrl 获取素材临时下载链接
//
// - 通过file_token获取素材临时下载链接，链接时效性是24小时，过期失效。
//
// - 该接口不支持太高的并发，且调用频率上限为5QPS
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/media/batch_get_tmp_download_url
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/batchGetTmpDownloadUrl_media.go
func (m *media) BatchGetTmpDownloadUrl(ctx context.Context, req *BatchGetTmpDownloadUrlMediaReq, options ...larkcore.RequestOptionFunc) (*BatchGetTmpDownloadUrlMediaResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/medias/batch_get_tmp_download_url"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, m.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &BatchGetTmpDownloadUrlMediaResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, m.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Download 下载素材
//
// - 使用该接口可以下载素材。素材表示在各种创作容器里的文件，如Doc文档内的图片，文件均属于素材。支持range下载。
//
// - 该接口不支持太高的并发，且调用频率上限为5QPS
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/media/download
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/download_media.go
func (m *media) Download(ctx context.Context, req *DownloadMediaReq, options ...larkcore.RequestOptionFunc) (*DownloadMediaResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/medias/:file_token/download"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, m.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &DownloadMediaResp{ApiResp: apiResp}
	// 如果是下载，则设置响应结果
	if apiResp.StatusCode == http.StatusOK {
		resp.File = bytes.NewBuffer(apiResp.RawBody)
		resp.FileName = larkcore.FileNameByHeader(apiResp.Header)
		return resp, err
	}
	err = apiResp.JSONUnmarshalBody(resp, m.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// UploadAll 上传素材
//
// - 将文件、图片、视频等素材文件上传到指定云文档中。素材文件在云空间中不会显示，只会显示在对应云文档中。
//
// - 请不要使用这个接口上传大于20MB的文件，如果有这个需求可以尝试使用[分片上传接口](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/media/multipart-upload-media/introduction)。
//
// - 该接口支持调用频率上限为5QPS
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/media/upload_all
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/uploadAll_media.go
func (m *media) UploadAll(ctx context.Context, req *UploadAllMediaReq, options ...larkcore.RequestOptionFunc) (*UploadAllMediaResp, error) {
	options = append(options, larkcore.WithFileUpload())
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/medias/upload_all"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, m.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &UploadAllMediaResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, m.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// UploadFinish 分片上传素材（完成上传）
//
// - 触发完成上传。
//
// - 该接口不支持太高的并发，且调用频率上限为5QPS
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/media/upload_finish
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/uploadFinish_media.go
func (m *media) UploadFinish(ctx context.Context, req *UploadFinishMediaReq, options ...larkcore.RequestOptionFunc) (*UploadFinishMediaResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/medias/upload_finish"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, m.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &UploadFinishMediaResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, m.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// UploadPart 分片上传素材（上传分片）
//
// - 上传对应的文件块。
//
// - 该接口不支持太高的并发，且调用频率上限为5QPS
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/media/upload_part
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/uploadPart_media.go
func (m *media) UploadPart(ctx context.Context, req *UploadPartMediaReq, options ...larkcore.RequestOptionFunc) (*UploadPartMediaResp, error) {
	options = append(options, larkcore.WithFileUpload())
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/medias/upload_part"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, m.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &UploadPartMediaResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, m.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// UploadPrepare 分片上传素材（预上传）
//
// - 发送初始化请求获取上传事务ID和分块策略，目前是以4MB大小进行定长分片。
//
// - 您在24小时内可保存上传事务ID和上传进度，以便可以恢复上传
//
// - 该接口不支持太高的并发，且调用频率上限为5QPS
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/media/upload_prepare
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/uploadPrepare_media.go
func (m *media) UploadPrepare(ctx context.Context, req *UploadPrepareMediaReq, options ...larkcore.RequestOptionFunc) (*UploadPrepareMediaResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/medias/upload_prepare"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, m.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &UploadPrepareMediaResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, m.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// BatchQuery 获取文档元数据
//
// - 该接口用于根据 token 获取各类文件的元数据
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/meta/batch_query
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/batchQuery_meta.go
func (m *meta) BatchQuery(ctx context.Context, req *BatchQueryMetaReq, options ...larkcore.RequestOptionFunc) (*BatchQueryMetaResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/metas/batch_query"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, m.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &BatchQueryMetaResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, m.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Auth
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=auth&project=drive&resource=permission.member&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/auth_permissionMember.go
func (p *permissionMember) Auth(ctx context.Context, req *AuthPermissionMemberReq, options ...larkcore.RequestOptionFunc) (*AuthPermissionMemberResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/permissions/:token/members/auth"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, p.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &AuthPermissionMemberResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, p.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Create 增加协作者权限
//
// - 该接口用于根据 filetoken 给用户增加文档的权限。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/permission-member/create
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/create_permissionMember.go
func (p *permissionMember) Create(ctx context.Context, req *CreatePermissionMemberReq, options ...larkcore.RequestOptionFunc) (*CreatePermissionMemberResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/permissions/:token/members"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, p.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &CreatePermissionMemberResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, p.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Delete 移除协作者权限
//
// - 该接口用于根据 filetoken 移除文档协作者的权限。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/permission-member/delete
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/delete_permissionMember.go
func (p *permissionMember) Delete(ctx context.Context, req *DeletePermissionMemberReq, options ...larkcore.RequestOptionFunc) (*DeletePermissionMemberResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/permissions/:token/members/:member_id"
	apiReq.HttpMethod = http.MethodDelete
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, p.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &DeletePermissionMemberResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, p.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// List 获取协作者列表
//
// - 该接口用于根据 filetoken 查询协作者
//
// - - 你能获取到协作者列表的前提是你对该文档有分享权限;- 目前仅支持人、群、组织架构三种类型的协作者
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/permission-member/list
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/list_permissionMember.go
func (p *permissionMember) List(ctx context.Context, req *ListPermissionMemberReq, options ...larkcore.RequestOptionFunc) (*ListPermissionMemberResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/permissions/:token/members"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, p.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &ListPermissionMemberResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, p.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// TransferOwner
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=transfer_owner&project=drive&resource=permission.member&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/transferOwner_permissionMember.go
func (p *permissionMember) TransferOwner(ctx context.Context, req *TransferOwnerPermissionMemberReq, options ...larkcore.RequestOptionFunc) (*TransferOwnerPermissionMemberResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/permissions/:token/members/transfer_owner"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, p.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &TransferOwnerPermissionMemberResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, p.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Update 更新协作者权限
//
// - 该接口用于根据 filetoken 更新文档协作者的权限。
//
// - 该接口要求文档协作者已存在，如还未对文档协作者授权请先调用[「增加权限」 ](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/permission-member/create)接口进行授权。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/permission-member/update
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/update_permissionMember.go
func (p *permissionMember) Update(ctx context.Context, req *UpdatePermissionMemberReq, options ...larkcore.RequestOptionFunc) (*UpdatePermissionMemberResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/permissions/:token/members/:member_id"
	apiReq.HttpMethod = http.MethodPut
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, p.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &UpdatePermissionMemberResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, p.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Get 获取云文档权限设置
//
// - 该接口用于根据 filetoken 获取云文档的权限设置。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/permission-public/get
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/get_permissionPublic.go
func (p *permissionPublic) Get(ctx context.Context, req *GetPermissionPublicReq, options ...larkcore.RequestOptionFunc) (*GetPermissionPublicResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/permissions/:token/public"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, p.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &GetPermissionPublicResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, p.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Patch 更新云文档权限设置
//
// - 该接口用于根据 filetoken 更新云文档的权限设置。
//
// - 官网API文档链接:https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/drive-v1/permission-public/patch
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/patch_permissionPublic.go
func (p *permissionPublic) Patch(ctx context.Context, req *PatchPermissionPublicReq, options ...larkcore.RequestOptionFunc) (*PatchPermissionPublicResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/permissions/:token/public"
	apiReq.HttpMethod = http.MethodPatch
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, p.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &PatchPermissionPublicResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, p.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Create
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=create&project=drive&resource=permission.public.password&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/create_permissionPublicPassword.go
func (p *permissionPublicPassword) Create(ctx context.Context, req *CreatePermissionPublicPasswordReq, options ...larkcore.RequestOptionFunc) (*CreatePermissionPublicPasswordResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/permissions/:token/public/password"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, p.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &CreatePermissionPublicPasswordResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, p.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Delete
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=delete&project=drive&resource=permission.public.password&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/delete_permissionPublicPassword.go
func (p *permissionPublicPassword) Delete(ctx context.Context, req *DeletePermissionPublicPasswordReq, options ...larkcore.RequestOptionFunc) (*DeletePermissionPublicPasswordResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/permissions/:token/public/password"
	apiReq.HttpMethod = http.MethodDelete
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, p.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &DeletePermissionPublicPasswordResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, p.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Update
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=update&project=drive&resource=permission.public.password&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/drivev1/update_permissionPublicPassword.go
func (p *permissionPublicPassword) Update(ctx context.Context, req *UpdatePermissionPublicPasswordReq, options ...larkcore.RequestOptionFunc) (*UpdatePermissionPublicPasswordResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/drive/v1/permissions/:token/public/password"
	apiReq.HttpMethod = http.MethodPut
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, p.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &UpdatePermissionPublicPasswordResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, p.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}
