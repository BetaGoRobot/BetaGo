name: LarkRobot

on:
  push:
    branches: [master]
    paths-ignore:
      - "neteaseapi/netease-api-service/*"
      - "qqmusicapi/qqmusic-api-service/*"
      - "README.md"
  pull_request:
    branches: [master]
    paths-ignore:
      - "neteaseapi/netease-api-service/*"
      - "qqmusicapi/qqmusic-api-service/*"
      - "README.md"
  workflow_dispatch:
    inputs:
      name:
        description: "触发用途"
        required: true
        default: "测试"

env:
  IMAGE_NAME: kevinmatt/larkbot
  ROBOT_NAME: LarkRobot
  NETEASE_PHONE: "${{ secrets.NETEASE_PHONE }}"
  NETEASE_PASSWORD: "${{ secrets.NETEASE_PASSWORD }}"
  TENCENT_HEADER: ccr.ccs.tencentyun.com

jobs:
  Build:
    runs-on: ubuntu-latest
    outputs:
      timestamp: ${{ steps.timestamp.outputs.timestamp }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4 # <-- 版本更新

      - name: Calculate timestamp
        id: timestamp
        run: echo "timestamp=$(date +%s%3N)" >> $GITHUB_OUTPUT

      # --- 新增：设置 Go ---
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25' # <-- 请根据你的 Dockerfile 中的 Go 版本调整
          cache: true # <-- 自动启用 Go 模块和构建缓存
          
      # --- 新增：获取 Go 缓存路径 ---
      # 我们需要缓存的
      # 1. 模块缓存 (GOMODCACHE)
      # 2. 构建缓存 (GOCACHE)
      - name: Get Go cache paths
        id: go-paths
        run: |
          echo "mod_cache_path=$(go env GOMODCACHE)" >> $GITHUB_OUTPUT
          echo "build_cache_path=$(go env GOCACHE)" >> $GITHUB_OUTPUT

      # --- 新增：预热 Go 模块缓存 ---
      # 这一步是可选的，但推荐。
      # 它可以确保 GOMODCACHE 目录在挂载前进 Docker 前是最新状态。
      - name: Download Go modules on runner
        run: go mod download

      - name: Log in to DockerHub
        uses: docker/login-action@v3 # <-- 版本更新
        with:
          username: kevinmatt
          password: ${{ secrets.DOCKER_ACCESS_TOKEN }}

      - name: Log in to GHCR
        uses: docker/login-action@v3 # <-- 版本更新
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
        
      - name: Log in to Tencent Cloud Registry
        uses: docker/login-action@v3 # <-- 版本更新
        with:
          registry: ${{ env.TENCENT_HEADER }}
          username: "100016072032"
          password: ${{ secrets.DOCKER_ACCESS_TOKEN }}
        
      # --- 修改：Build 步骤 ---
      - name: Build and Save Docker image
        run: |
          zip -r -9 -q betago.zip . -x ".git/*" -x "dal/qqmusicapi/qqmusic-api-service/*" -x "dal/neteaseapi/netease-api-service/*"
          
          # 关键：使用 --mount 将 Runner 上的 Go 缓存目录挂载到 Docker Build 内部
          # 我们假设 Dockerfile 内部的 Go 默认 GOMODCACHE 是 /go/pkg/mod
          # 我们假设 Dockerfile 内部的 Go 默认 GOCACHE 是 /root/.cache/go-build (因为构建通常是 root 用户)
          DOCKER_BUILDKIT=1 docker build . \
            --file scripts/larkrobot/Dockerfile \
            --tag $IMAGE_NAME:latest \
            --tag $IMAGE_NAME:latest-${{ steps.timestamp.outputs.timestamp }} \
            --mount=type=bind,source=${{ steps.go-paths.outputs.mod_cache_path }},target=/go/pkg/mod \
            --mount=type=bind,source=${{ steps.go-paths.outputs.build_cache_path }},target=/root/.cache/go-build
            
          docker save $IMAGE_NAME:latest | gzip > image_latest.tar.gz
          docker save $IMAGE_NAME:latest-${{ steps.timestamp.outputs.timestamp }} | gzip > image_timestamp.tar.gz

      - name: Upload image artifacts
        uses: actions/upload-artifact@v4
        with:
          name: docker-images
          path: |
            image_latest.tar.gz
            image_timestamp.tar.gz

  PushToDockerHub:
    # ... (后续 Job 保持不变) ...
    needs: Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: docker-images

      - name: Load Docker image
        run: |
          gunzip -c image_latest.tar.gz | docker load
          gunzip -c image_timestamp.tar.gz | docker load

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: kevinmatt
          password: ${{ secrets.DOCKER_ACCESS_TOKEN }}

      - name: Push to DockerHub
        run: |
          docker push $IMAGE_NAME:latest
          docker push $IMAGE_NAME:latest-${{ needs.Build.outputs.timestamp }}

  # PushToGHCR:
  # ... (保持不变) ...

  # PushToTencentCloud:
  # ... (保持不变) ...

  Notify:
    if: github.event_name != 'pull_request'
    needs: [PushToDockerHub]
    runs-on: ubuntu-latest
    steps:
      - name: Gotify Notification
        uses: eikendev/gotify-action@master
        with:
          gotify_api_base: '${{ secrets.GOTIFY_URL }}'
          gotify_app_token: '${{ secrets.GOTIFY_APP_TOKEN }}'
          notification_title: '${{ env.ROBOT_NAME }} Build Complete'
          notification_message: 'Your build was completed.'